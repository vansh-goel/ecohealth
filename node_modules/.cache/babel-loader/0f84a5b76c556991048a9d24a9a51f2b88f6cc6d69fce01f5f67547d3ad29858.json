{"ast":null,"code":"/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is a utility class that makes it easier to work with asynchronous tasks.\n// Here's why I don't just use Promises:\n// (a) I don't want to depend on a Promise implementation.\n// (b) Promises aren't cancellable (yet?), and I want cancellability.\n//\n// This is very stripped down, compared to Promises.\n// (a) You can only call .thenDo() once. Because there's only one party waiting\n//     on the result of a task, cancelling always propagates backwards.\n// (b) The argument to .thenDo() must return either undefined or a Task. I don't\n//     promote values to Tasks, like what happens with Promises.\n\nvar Task = exports;\n\n/**\n * Creates a Task.\n *\n * The `doSomething` function is called immediately, so that it can start\n * whatever work is part of this task.\n *\n * The `doSomething` function is given a resolve function and a reject function,\n * and it should call one of them when the task is finished, to report its\n * result.\n *\n * The `doSomething` function can optionally return a cancel function. This will\n * be called if the task is cancelled.\n *\n * @param  {function(function(T), function(?)): function()} doSomething\n * @return {Task<T>}\n * @template T\n */\nTask.start = function (doSomething) {\n  var me = {};\n\n  // onFinish should be called as soon as both finished and onFinish are\n  // defined. It should be called by the piece of code that just defined either\n  // finished or onFinish.\n  var finished;\n  var onFinish;\n  var cleaners = [];\n  function finish(err, result) {\n    if (!finished) {\n      finished = {\n        err: err,\n        result: result\n      };\n      if (onFinish) {\n        onFinish();\n        // To prevent memory leaks, delete our reference to onFinish after\n        // calling it.\n        onFinish = function () {};\n      }\n      var cleanup;\n      while (cleanup = cleaners.pop()) {\n        cleanup();\n      }\n      if (err === 'cancelled') {\n        if (abort) abort();\n      }\n      abort = null;\n    }\n  }\n  try {\n    // doSomething must be called immediately.\n    var abort = doSomething(function (result) {\n      finish(null, result);\n    }, function (err) {\n      finish(err, null);\n    });\n  } catch (err) {\n    finish(err, null);\n  }\n\n  /**\n   * Cancels the task (unless the task has already finished, in which case\n   * this call is ignored).\n   *\n   * Subsequent tasks created with #thenDo will not be started. However, clean-\n   * up code added with #finished will run.\n   */\n  me.cancel = function () {\n    finish('cancelled', null);\n  };\n\n  /**\n   * Sets the listener that will be called with the result of this task, when\n   * finished. This function can be called at most once.\n   *\n   * @param {function(?, T)} callback\n   */\n  function setListener(callback) {\n    if (onFinish) {\n      throw new Error('thenDo/finally called more than once');\n    }\n    if (finished) {\n      onFinish = function () {};\n      callback(finished.err, finished.result);\n    } else {\n      onFinish = function () {\n        callback(finished.err, finished.result);\n      };\n    }\n  }\n\n  /**\n   * Creates and returns a composite task, consisting of this task and a\n   * subsequent task.\n   *\n   * @param {function(T): ?Task<U>} onResolve A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the result of this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @param {function(?): ?Task<U>} onReject A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the error produced by this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @return {Task<U>} The composite task. Cancelling the composite task cancels\n   *     either this task or the subsequent task, depending on whether this\n   *     task is finished.\n   * @template U\n   */\n  me.thenDo = function (onResolve, onReject) {\n    return compose(me, setListener, onResolve, onReject);\n  };\n\n  /**\n   * Registers a cleanup function, that will be run when the task finishes,\n   * regardless of error or cancellation.\n   *\n   * @param {function()} cleanup\n   * @return {THIS}\n   */\n  me.finally = function (cleanup) {\n    if (!finished) {\n      cleaners.push(function () {\n        process.nextTick(cleanup);\n      });\n    } else {\n      process.nextTick(cleanup);\n    }\n    return me;\n  };\n  return me;\n};\n\n/**\n * Creates a Task with the given result.\n */\nTask.withValue = function (result) {\n  return Task.start(function (resolve) {\n    resolve(result);\n  });\n};\n\n/**\n * Creates a Task with the given error.\n */\nTask.withError = function (err) {\n  return Task.start(function (resolve, reject) {\n    reject(err);\n  });\n};\n\n/**\n * Returns a new task that races the given tasks. Eventually finishes with the\n * result or error of whichever task finishes first. If any task is cancelled,\n * all of the tasks are cancelled.\n *\n * @param {Array<Task<T>>} tasks\n * @return {Task<T>}\n * @template T\n */\nTask.race = function (tasks) {\n  return Task.start(function (resolve, reject) {\n    function cancelAll() {\n      tasks.forEach(function (task) {\n        task.cancel();\n      });\n    }\n    tasks.forEach(function (task) {\n      task.finally(cancelAll).thenDo(resolve, reject);\n    });\n    return cancelAll;\n  });\n};\n\n/**\n * Creates a composite task, which uses the output of the first task to create\n * a subsequent task, and represents the two tasks together.\n *\n * This function is internal-only. It is used by Task.thenDo().\n *\n * @param {Task<T>} firstTask\n * @param {function(function(?, T))} whenFirstTaskFinishes The private\n *     setListener method on the firstTask.\n * @param {function(T): Task<U>} onResolve\n * @param {function(?): Task<U>} onReject\n * @return {Task<U>}\n * @template T, U\n */\nfunction compose(firstTask, whenFirstTaskFinishes, onResolve, onReject) {\n  return Task.start(function (resolve, reject) {\n    var cancelled;\n    var currentTask = firstTask;\n    whenFirstTaskFinishes(function (err, result) {\n      currentTask = null;\n      // createSubsequentTask must be called asynchronously.\n      process.nextTick(function () {\n        if (cancelled || err === 'cancelled') {\n          return reject('cancelled');\n        }\n\n        // Start the subsequent task.\n        if (err == null) {\n          if (!onResolve) {\n            return resolve(result);\n          }\n          try {\n            currentTask = onResolve(result);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        } else {\n          if (!onReject) {\n            return reject(err);\n          }\n          try {\n            currentTask = onReject(err);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        }\n\n        // Was a subsequent task returned?\n        if (!currentTask) {\n          return resolve(undefined);\n        }\n        currentTask.thenDo(resolve, reject);\n      });\n    });\n    return function cancelCompositeTask() {\n      cancelled = true;\n      if (currentTask) {\n        currentTask.cancel();\n      }\n    };\n  });\n}","map":{"version":3,"names":["Task","exports","start","doSomething","me","finished","onFinish","cleaners","finish","err","result","cleanup","pop","abort","cancel","setListener","callback","Error","thenDo","onResolve","onReject","compose","finally","push","process","nextTick","withValue","resolve","withError","reject","race","tasks","cancelAll","forEach","task","firstTask","whenFirstTaskFinishes","cancelled","currentTask","caughtErr","undefined","cancelCompositeTask"],"sources":["/home/vanshgoel/Downloads/ecohealth-react/node_modules/.pnpm/@google+maps@1.1.3/node_modules/@google/maps/lib/internal/task.js"],"sourcesContent":["/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// This is a utility class that makes it easier to work with asynchronous tasks.\n// Here's why I don't just use Promises:\n// (a) I don't want to depend on a Promise implementation.\n// (b) Promises aren't cancellable (yet?), and I want cancellability.\n//\n// This is very stripped down, compared to Promises.\n// (a) You can only call .thenDo() once. Because there's only one party waiting\n//     on the result of a task, cancelling always propagates backwards.\n// (b) The argument to .thenDo() must return either undefined or a Task. I don't\n//     promote values to Tasks, like what happens with Promises.\n\nvar Task = exports;\n\n/**\n * Creates a Task.\n *\n * The `doSomething` function is called immediately, so that it can start\n * whatever work is part of this task.\n *\n * The `doSomething` function is given a resolve function and a reject function,\n * and it should call one of them when the task is finished, to report its\n * result.\n *\n * The `doSomething` function can optionally return a cancel function. This will\n * be called if the task is cancelled.\n *\n * @param  {function(function(T), function(?)): function()} doSomething\n * @return {Task<T>}\n * @template T\n */\nTask.start = function(doSomething) {\n  var me = {};\n\n  // onFinish should be called as soon as both finished and onFinish are\n  // defined. It should be called by the piece of code that just defined either\n  // finished or onFinish.\n  var finished;\n  var onFinish;\n  var cleaners = [];\n\n  function finish(err, result) {\n    if (!finished) {\n      finished = {err: err, result: result};\n\n      if (onFinish) {\n        onFinish();\n        // To prevent memory leaks, delete our reference to onFinish after\n        // calling it.\n        onFinish = function() {};\n      }\n\n      var cleanup;\n      while (cleanup = cleaners.pop()) {\n        cleanup();\n      }\n\n      if (err === 'cancelled') {\n        if (abort) abort();\n      }\n\n      abort = null;\n    }\n  }\n\n  try {\n    // doSomething must be called immediately.\n    var abort = doSomething(\n        function(result) { finish(null, result); },\n        function(err)    { finish(err,  null);   });\n  } catch (err) {\n    finish(err, null);\n  }\n\n  /**\n   * Cancels the task (unless the task has already finished, in which case\n   * this call is ignored).\n   *\n   * Subsequent tasks created with #thenDo will not be started. However, clean-\n   * up code added with #finished will run.\n   */\n  me.cancel = function() {\n    finish('cancelled', null);\n  };\n\n  /**\n   * Sets the listener that will be called with the result of this task, when\n   * finished. This function can be called at most once.\n   *\n   * @param {function(?, T)} callback\n   */\n  function setListener(callback) {\n    if (onFinish) {\n      throw new Error('thenDo/finally called more than once');\n    }\n    if (finished) {\n      onFinish = function() {};\n      callback(finished.err, finished.result);\n    } else {\n      onFinish = function() {\n        callback(finished.err, finished.result);\n      };\n    }\n  }\n\n  /**\n   * Creates and returns a composite task, consisting of this task and a\n   * subsequent task.\n   *\n   * @param {function(T): ?Task<U>} onResolve A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the result of this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @param {function(?): ?Task<U>} onReject A function that will\n   *     create a subsequent task. This function will be called\n   *     asynchronously, with the error produced by this task, when it\n   *     finishes. The return value must be a Task, or null/undefined.\n   * @return {Task<U>} The composite task. Cancelling the composite task cancels\n   *     either this task or the subsequent task, depending on whether this\n   *     task is finished.\n   * @template U\n   */\n  me.thenDo = function(onResolve, onReject) {\n    return compose(me, setListener, onResolve, onReject);\n  };\n\n  /**\n   * Registers a cleanup function, that will be run when the task finishes,\n   * regardless of error or cancellation.\n   *\n   * @param {function()} cleanup\n   * @return {THIS}\n   */\n  me.finally = function(cleanup) {\n    if (!finished) {\n      cleaners.push(function() {\n        process.nextTick(cleanup);\n      });\n    } else {\n      process.nextTick(cleanup);\n    }\n    return me;\n  };\n\n  return me;\n};\n\n/**\n * Creates a Task with the given result.\n */\nTask.withValue = function(result) {\n  return Task.start(function(resolve) {\n    resolve(result);\n  });\n};\n\n/**\n * Creates a Task with the given error.\n */\nTask.withError = function(err) {\n  return Task.start(function(resolve, reject) {\n    reject(err);\n  });\n};\n\n/**\n * Returns a new task that races the given tasks. Eventually finishes with the\n * result or error of whichever task finishes first. If any task is cancelled,\n * all of the tasks are cancelled.\n *\n * @param {Array<Task<T>>} tasks\n * @return {Task<T>}\n * @template T\n */\nTask.race = function(tasks) {\n  return Task.start(function(resolve, reject) {\n    function cancelAll() {\n      tasks.forEach(function(task) {\n        task.cancel();\n      });\n    }\n    tasks.forEach(function(task) {\n      task.finally(cancelAll).thenDo(resolve, reject);\n    });\n    return cancelAll;\n  });\n};\n\n/**\n * Creates a composite task, which uses the output of the first task to create\n * a subsequent task, and represents the two tasks together.\n *\n * This function is internal-only. It is used by Task.thenDo().\n *\n * @param {Task<T>} firstTask\n * @param {function(function(?, T))} whenFirstTaskFinishes The private\n *     setListener method on the firstTask.\n * @param {function(T): Task<U>} onResolve\n * @param {function(?): Task<U>} onReject\n * @return {Task<U>}\n * @template T, U\n */\nfunction compose(firstTask, whenFirstTaskFinishes, onResolve, onReject) {\n  return Task.start(function(resolve, reject) {\n    var cancelled;\n    var currentTask = firstTask;\n\n    whenFirstTaskFinishes(function(err, result) {\n      currentTask = null;\n      // createSubsequentTask must be called asynchronously.\n      process.nextTick(function() {\n        if (cancelled || err === 'cancelled') {\n          return reject('cancelled');\n        }\n\n        // Start the subsequent task.\n        if (err == null) {\n          if (!onResolve) {\n            return resolve(result);\n          }\n          try {\n            currentTask = onResolve(result);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        } else {\n          if (!onReject) {\n            return reject(err);\n          }\n          try {\n            currentTask = onReject(err);\n          } catch (caughtErr) {\n            return reject(caughtErr);\n          }\n        }\n\n        // Was a subsequent task returned?\n        if (!currentTask) {\n          return resolve(undefined);\n        }\n\n        currentTask.thenDo(resolve, reject);\n      });\n    });\n\n    return function cancelCompositeTask() {\n      cancelled = true;\n      if (currentTask) {\n        currentTask.cancel();\n      }\n    };\n  });\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}