{"ast":null,"code":"/**\n * Module dependencies.\n */\n\nvar net = require('net');\nvar tls = require('tls');\nvar url = require('url');\nvar assert = require('assert');\nvar Agent = require('agent-base');\nvar inherits = require('util').inherits;\nvar debug = require('debug')('https-proxy-agent');\n\n/**\n * Module exports.\n */\n\nmodule.exports = HttpsProxyAgent;\n\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the\n * specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * @api public\n */\n\nfunction HttpsProxyAgent(opts) {\n  if (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);\n  if ('string' == typeof opts) opts = url.parse(opts);\n  if (!opts) throw new Error('an HTTP(S) proxy server `host` and `port` must be specified!');\n  debug('creating new HttpsProxyAgent instance: %o', opts);\n  Agent.call(this, opts);\n  var proxy = Object.assign({}, opts);\n\n  // if `true`, then connect to the proxy server over TLS. defaults to `false`.\n  this.secureProxy = proxy.protocol ? /^https:?$/i.test(proxy.protocol) : false;\n\n  // prefer `hostname` over `host`, and set the `port` if needed\n  proxy.host = proxy.hostname || proxy.host;\n  proxy.port = +proxy.port || (this.secureProxy ? 443 : 80);\n\n  // ALPN is supported by Node.js >= v5.\n  // attempt to negotiate http/1.1 for proxy servers that support http/2\n  if (this.secureProxy && !('ALPNProtocols' in proxy)) {\n    proxy.ALPNProtocols = ['http 1.1'];\n  }\n  if (proxy.host && proxy.path) {\n    // if both a `host` and `path` are specified then it's most likely the\n    // result of a `url.parse()` call... we need to remove the `path` portion so\n    // that `net.connect()` doesn't attempt to open that as a unix socket file.\n    delete proxy.path;\n    delete proxy.pathname;\n  }\n  this.proxy = proxy;\n  this.defaultPort = 443;\n}\ninherits(HttpsProxyAgent, Agent);\n\n/**\n * Called when the node-core HTTP client library is creating a new HTTP request.\n *\n * @api public\n */\n\nHttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {\n  var proxy = this.proxy;\n\n  // create a socket connection to the proxy server\n  var socket;\n  if (this.secureProxy) {\n    socket = tls.connect(proxy);\n  } else {\n    socket = net.connect(proxy);\n  }\n\n  // we need to buffer any HTTP traffic that happens with the proxy before we get\n  // the CONNECT response, so that if the response is anything other than an \"200\"\n  // response code, then we can re-play the \"data\" events on the socket once the\n  // HTTP parser is hooked up...\n  var buffers = [];\n  var buffersLength = 0;\n  function read() {\n    var b = socket.read();\n    if (b) ondata(b);else socket.once('readable', read);\n  }\n  function cleanup() {\n    socket.removeListener('end', onend);\n    socket.removeListener('error', onerror);\n    socket.removeListener('close', onclose);\n    socket.removeListener('readable', read);\n  }\n  function onclose(err) {\n    debug('onclose had error %o', err);\n  }\n  function onend() {\n    debug('onend');\n  }\n  function onerror(err) {\n    cleanup();\n    fn(err);\n  }\n  function ondata(b) {\n    buffers.push(b);\n    buffersLength += b.length;\n    var buffered = Buffer.concat(buffers, buffersLength);\n    var str = buffered.toString('ascii');\n    if (!~str.indexOf('\\r\\n\\r\\n')) {\n      // keep buffering\n      debug('have not received end of HTTP headers yet...');\n      read();\n      return;\n    }\n    var firstLine = str.substring(0, str.indexOf('\\r\\n'));\n    var statusCode = +firstLine.split(' ')[1];\n    debug('got proxy server response: %o', firstLine);\n    if (200 == statusCode) {\n      // 200 Connected status code!\n      var sock = socket;\n\n      // nullify the buffered data since we won't be needing it\n      buffers = buffered = null;\n      if (opts.secureEndpoint) {\n        // since the proxy is connecting to an SSL server, we have\n        // to upgrade this socket connection to an SSL connection\n        debug('upgrading proxy-connected socket to TLS connection: %o', opts.host);\n        opts.socket = socket;\n        opts.servername = opts.servername || opts.host;\n        opts.host = null;\n        opts.hostname = null;\n        opts.port = null;\n        sock = tls.connect(opts);\n      }\n      cleanup();\n      req.once('socket', resume);\n      fn(null, sock);\n    } else {\n      // some other status code that's not 200... need to re-play the HTTP header\n      // \"data\" events onto the socket once the HTTP machinery is attached so\n      // that the node core `http` can parse and handle the error status code\n      cleanup();\n\n      // the original socket is closed, and a new closed socket is\n      // returned instead, so that the proxy doesn't get the HTTP request\n      // written to it (which may contain `Authorization` headers or other\n      // sensitive data).\n      //\n      // See: https://hackerone.com/reports/541502\n      socket.destroy();\n      socket = new net.Socket();\n      socket.readable = true;\n\n      // save a reference to the concat'd Buffer for the `onsocket` callback\n      buffers = buffered;\n\n      // need to wait for the \"socket\" event to re-play the \"data\" events\n      req.once('socket', onsocket);\n      fn(null, socket);\n    }\n  }\n  function onsocket(socket) {\n    debug('replaying proxy buffer for failed request');\n    assert(socket.listenerCount('data') > 0);\n\n    // replay the \"buffers\" Buffer onto the `socket`, since at this point\n    // the HTTP module machinery has been hooked up for the user\n    socket.push(buffers);\n\n    // nullify the cached Buffer instance\n    buffers = null;\n  }\n  socket.on('error', onerror);\n  socket.on('close', onclose);\n  socket.on('end', onend);\n  read();\n  var hostname = opts.host + ':' + opts.port;\n  var msg = 'CONNECT ' + hostname + ' HTTP/1.1\\r\\n';\n  var headers = Object.assign({}, proxy.headers);\n  if (proxy.auth) {\n    headers['Proxy-Authorization'] = 'Basic ' + Buffer.from(proxy.auth).toString('base64');\n  }\n\n  // the Host header should only include the port\n  // number when it is a non-standard port\n  var host = opts.host;\n  if (!isDefaultPort(opts.port, opts.secureEndpoint)) {\n    host += ':' + opts.port;\n  }\n  headers['Host'] = host;\n  headers['Connection'] = 'close';\n  Object.keys(headers).forEach(function (name) {\n    msg += name + ': ' + headers[name] + '\\r\\n';\n  });\n  socket.write(msg + '\\r\\n');\n};\n\n/**\n * Resumes a socket.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket to resume\n * @api public\n */\n\nfunction resume(socket) {\n  socket.resume();\n}\nfunction isDefaultPort(port, secure) {\n  return Boolean(!secure && port === 80 || secure && port === 443);\n}","map":{"version":3,"names":["net","require","tls","url","assert","Agent","inherits","debug","module","exports","HttpsProxyAgent","opts","parse","Error","call","proxy","Object","assign","secureProxy","protocol","test","host","hostname","port","ALPNProtocols","path","pathname","defaultPort","prototype","callback","connect","req","fn","socket","buffers","buffersLength","read","b","ondata","once","cleanup","removeListener","onend","onerror","onclose","err","push","length","buffered","Buffer","concat","str","toString","indexOf","firstLine","substring","statusCode","split","sock","secureEndpoint","servername","resume","destroy","Socket","readable","onsocket","listenerCount","on","msg","headers","auth","from","isDefaultPort","keys","forEach","name","write","secure","Boolean"],"sources":["/home/vanshgoel/Downloads/ecohealth-react/node_modules/.pnpm/https-proxy-agent@3.0.1/node_modules/https-proxy-agent/index.js"],"sourcesContent":["/**\n * Module dependencies.\n */\n\nvar net = require('net');\nvar tls = require('tls');\nvar url = require('url');\nvar assert = require('assert');\nvar Agent = require('agent-base');\nvar inherits = require('util').inherits;\nvar debug = require('debug')('https-proxy-agent');\n\n/**\n * Module exports.\n */\n\nmodule.exports = HttpsProxyAgent;\n\n/**\n * The `HttpsProxyAgent` implements an HTTP Agent subclass that connects to the\n * specified \"HTTP(s) proxy server\" in order to proxy HTTPS requests.\n *\n * @api public\n */\n\nfunction HttpsProxyAgent(opts) {\n\tif (!(this instanceof HttpsProxyAgent)) return new HttpsProxyAgent(opts);\n\tif ('string' == typeof opts) opts = url.parse(opts);\n\tif (!opts)\n\t\tthrow new Error(\n\t\t\t'an HTTP(S) proxy server `host` and `port` must be specified!'\n\t\t);\n\tdebug('creating new HttpsProxyAgent instance: %o', opts);\n\tAgent.call(this, opts);\n\n\tvar proxy = Object.assign({}, opts);\n\n\t// if `true`, then connect to the proxy server over TLS. defaults to `false`.\n\tthis.secureProxy = proxy.protocol\n\t\t? /^https:?$/i.test(proxy.protocol)\n\t\t: false;\n\n\t// prefer `hostname` over `host`, and set the `port` if needed\n\tproxy.host = proxy.hostname || proxy.host;\n\tproxy.port = +proxy.port || (this.secureProxy ? 443 : 80);\n\n\t// ALPN is supported by Node.js >= v5.\n\t// attempt to negotiate http/1.1 for proxy servers that support http/2\n\tif (this.secureProxy && !('ALPNProtocols' in proxy)) {\n\t\tproxy.ALPNProtocols = ['http 1.1'];\n\t}\n\n\tif (proxy.host && proxy.path) {\n\t\t// if both a `host` and `path` are specified then it's most likely the\n\t\t// result of a `url.parse()` call... we need to remove the `path` portion so\n\t\t// that `net.connect()` doesn't attempt to open that as a unix socket file.\n\t\tdelete proxy.path;\n\t\tdelete proxy.pathname;\n\t}\n\n\tthis.proxy = proxy;\n\tthis.defaultPort = 443;\n}\ninherits(HttpsProxyAgent, Agent);\n\n/**\n * Called when the node-core HTTP client library is creating a new HTTP request.\n *\n * @api public\n */\n\nHttpsProxyAgent.prototype.callback = function connect(req, opts, fn) {\n\tvar proxy = this.proxy;\n\n\t// create a socket connection to the proxy server\n\tvar socket;\n\tif (this.secureProxy) {\n\t\tsocket = tls.connect(proxy);\n\t} else {\n\t\tsocket = net.connect(proxy);\n\t}\n\n\t// we need to buffer any HTTP traffic that happens with the proxy before we get\n\t// the CONNECT response, so that if the response is anything other than an \"200\"\n\t// response code, then we can re-play the \"data\" events on the socket once the\n\t// HTTP parser is hooked up...\n\tvar buffers = [];\n\tvar buffersLength = 0;\n\n\tfunction read() {\n\t\tvar b = socket.read();\n\t\tif (b) ondata(b);\n\t\telse socket.once('readable', read);\n\t}\n\n\tfunction cleanup() {\n\t\tsocket.removeListener('end', onend);\n\t\tsocket.removeListener('error', onerror);\n\t\tsocket.removeListener('close', onclose);\n\t\tsocket.removeListener('readable', read);\n\t}\n\n\tfunction onclose(err) {\n\t\tdebug('onclose had error %o', err);\n\t}\n\n\tfunction onend() {\n\t\tdebug('onend');\n\t}\n\n\tfunction onerror(err) {\n\t\tcleanup();\n\t\tfn(err);\n\t}\n\n\tfunction ondata(b) {\n\t\tbuffers.push(b);\n\t\tbuffersLength += b.length;\n\t\tvar buffered = Buffer.concat(buffers, buffersLength);\n\t\tvar str = buffered.toString('ascii');\n\n\t\tif (!~str.indexOf('\\r\\n\\r\\n')) {\n\t\t\t// keep buffering\n\t\t\tdebug('have not received end of HTTP headers yet...');\n\t\t\tread();\n\t\t\treturn;\n\t\t}\n\n\t\tvar firstLine = str.substring(0, str.indexOf('\\r\\n'));\n\t\tvar statusCode = +firstLine.split(' ')[1];\n\t\tdebug('got proxy server response: %o', firstLine);\n\n\t\tif (200 == statusCode) {\n\t\t\t// 200 Connected status code!\n\t\t\tvar sock = socket;\n\n\t\t\t// nullify the buffered data since we won't be needing it\n\t\t\tbuffers = buffered = null;\n\n\t\t\tif (opts.secureEndpoint) {\n\t\t\t\t// since the proxy is connecting to an SSL server, we have\n\t\t\t\t// to upgrade this socket connection to an SSL connection\n\t\t\t\tdebug(\n\t\t\t\t\t'upgrading proxy-connected socket to TLS connection: %o',\n\t\t\t\t\topts.host\n\t\t\t\t);\n\t\t\t\topts.socket = socket;\n\t\t\t\topts.servername = opts.servername || opts.host;\n\t\t\t\topts.host = null;\n\t\t\t\topts.hostname = null;\n\t\t\t\topts.port = null;\n\t\t\t\tsock = tls.connect(opts);\n\t\t\t}\n\n\t\t\tcleanup();\n\t\t\treq.once('socket', resume);\n\t\t\tfn(null, sock);\n\t\t} else {\n\t\t\t// some other status code that's not 200... need to re-play the HTTP header\n\t\t\t// \"data\" events onto the socket once the HTTP machinery is attached so\n\t\t\t// that the node core `http` can parse and handle the error status code\n\t\t\tcleanup();\n\n\t\t\t// the original socket is closed, and a new closed socket is\n\t\t\t// returned instead, so that the proxy doesn't get the HTTP request\n\t\t\t// written to it (which may contain `Authorization` headers or other\n\t\t\t// sensitive data).\n\t\t\t//\n\t\t\t// See: https://hackerone.com/reports/541502\n\t\t\tsocket.destroy();\n\t\t\tsocket = new net.Socket();\n\t\t\tsocket.readable = true;\n\n\n\t\t\t// save a reference to the concat'd Buffer for the `onsocket` callback\n\t\t\tbuffers = buffered;\n\n\t\t\t// need to wait for the \"socket\" event to re-play the \"data\" events\n\t\t\treq.once('socket', onsocket);\n\n\t\t\tfn(null, socket);\n\t\t}\n\t}\n\n\tfunction onsocket(socket) {\n\t\tdebug('replaying proxy buffer for failed request');\n\t\tassert(socket.listenerCount('data') > 0);\n\n\t\t// replay the \"buffers\" Buffer onto the `socket`, since at this point\n\t\t// the HTTP module machinery has been hooked up for the user\n\t\tsocket.push(buffers);\n\n\t\t// nullify the cached Buffer instance\n\t\tbuffers = null;\n\t}\n\n\tsocket.on('error', onerror);\n\tsocket.on('close', onclose);\n\tsocket.on('end', onend);\n\n\tread();\n\n\tvar hostname = opts.host + ':' + opts.port;\n\tvar msg = 'CONNECT ' + hostname + ' HTTP/1.1\\r\\n';\n\n\tvar headers = Object.assign({}, proxy.headers);\n\tif (proxy.auth) {\n\t\theaders['Proxy-Authorization'] =\n\t\t\t'Basic ' + Buffer.from(proxy.auth).toString('base64');\n\t}\n\n\t// the Host header should only include the port\n\t// number when it is a non-standard port\n\tvar host = opts.host;\n\tif (!isDefaultPort(opts.port, opts.secureEndpoint)) {\n\t\thost += ':' + opts.port;\n\t}\n\theaders['Host'] = host;\n\n\theaders['Connection'] = 'close';\n\tObject.keys(headers).forEach(function(name) {\n\t\tmsg += name + ': ' + headers[name] + '\\r\\n';\n\t});\n\n\tsocket.write(msg + '\\r\\n');\n};\n\n/**\n * Resumes a socket.\n *\n * @param {(net.Socket|tls.Socket)} socket The socket to resume\n * @api public\n */\n\nfunction resume(socket) {\n\tsocket.resume();\n}\n\nfunction isDefaultPort(port, secure) {\n\treturn Boolean((!secure && port === 80) || (secure && port === 443));\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}