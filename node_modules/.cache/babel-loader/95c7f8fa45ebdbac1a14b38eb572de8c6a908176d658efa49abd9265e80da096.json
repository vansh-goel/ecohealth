{"ast":null,"code":"/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar url = require('url');\nvar Task = require('./task');\nconst EXPERIENCE_ID_HEADER_NAME = \"X-GOOG-MAPS-EXPERIENCE-ID\";\nexports.inject = function (options) {\n  var key = options.key || process.env.GOOGLE_MAPS_API_KEY;\n  var channel = options.channel;\n  var clientId = options.clientId || process.env.GOOGLE_MAPS_API_CLIENT_ID;\n  var clientSecret = options.clientSecret || process.env.GOOGLE_MAPS_API_CLIENT_SECRET;\n  var rate = options.rate || {};\n  var rateLimit = rate.limit || 50; // 50 requests per ratePeriod.\n  var ratePeriod = rate.period || 1000; // 1 second.\n\n  var makeUrlRequest = options.makeUrlRequest || require('./make-url-request');\n  var mySetTimeout = options.setTimeout || setTimeout;\n  var myClearTimeout = options.clearTimeout || clearTimeout;\n  var getTime = options.getTime || function () {\n    return new Date().getTime();\n  };\n  var wait = require('./wait').inject(mySetTimeout, myClearTimeout);\n  var attempt = require('./attempt').inject(wait).attempt;\n  var ThrottledQueue = require('./throttled-queue').inject(wait, getTime);\n  var requestQueue = ThrottledQueue.create(rateLimit, ratePeriod);\n\n  /**\n   * Makes an API request using the injected makeUrlRequest.\n   *\n   * Inserts the API key (or client ID and signature) into the query\n   * parameters. Retries requests when the status code requires it.\n   * Parses the response body as JSON.\n   *\n   * The callback is given either an error or a response. The response\n   * is an object with the following entries:\n   * {\n   *   status: number,\n   *   body: string,\n   *   json: Object\n   * }\n   *\n   * @param {string} path\n   * @param {Object} query This function mutates the query object.\n   * @param {Function} callback\n   * @return {{\n   *   cancel: function(),\n   *   finally: function(function()),\n   *   asPromise: function(): Promise\n   * }}\n   */\n  return function (path, query, callback) {\n    callback = callback || function () {};\n    var retryOptions = query.retryOptions || options.retryOptions || {};\n    delete query.retryOptions;\n    var timeout = query.timeout || options.timeout || 60 * 1000;\n    delete query.timeout;\n    var useClientId = query.supportsClientId && clientId && clientSecret;\n    delete query.supportsClientId;\n    var queryOptions = query.options || {};\n    delete query.options;\n    var isPost = queryOptions.method === 'POST';\n    var requestUrl = formatRequestUrl(path, isPost ? {} : query, useClientId);\n    if (isPost) {\n      queryOptions.body = query;\n    }\n    if (options.experienceId) {\n      queryOptions[\"headers\"] = queryOptions[\"headers\"] || {};\n      queryOptions[\"headers\"][EXPERIENCE_ID_HEADER_NAME] = options.experienceId.join(\",\");\n    }\n\n    // Determines whether a response indicates a retriable error.\n    var canRetry = queryOptions.canRetry || function (response, query) {\n      return response == null || response.status === 500 || response.status === 503 || response.status === 504 || response.json && (response.json.status === 'OVER_QUERY_LIMIT' || response.json.status === 'RESOURCE_EXHAUSTED' || response.json.status === 'INVALID_REQUEST' && query.pagetoken);\n    };\n    delete queryOptions.canRetry;\n\n    // Determines whether a response indicates success.\n    var isSuccessful = queryOptions.isSuccessful || function (response) {\n      return response.status === 200 && (response.json == undefined || response.json.status === undefined || response.json.status === 'OK' || response.json.status === 'ZERO_RESULTS');\n    };\n    delete queryOptions.isSuccessful;\n    function rateLimitedGet() {\n      return requestQueue.add(function () {\n        return Task.start(function (resolve, reject) {\n          return makeUrlRequest(requestUrl, resolve, reject, queryOptions);\n        });\n      });\n    }\n    var timeoutTask = wait(timeout).thenDo(function () {\n      throw 'timeout';\n    });\n    var requestTask = attempt({\n      'do': rateLimitedGet,\n      until: function (response) {\n        return !canRetry(response, query);\n      },\n      interval: retryOptions.interval,\n      increment: retryOptions.increment,\n      jitter: retryOptions.jitter\n    });\n    var task = Task.race([timeoutTask, requestTask]).thenDo(function (response) {\n      // We add the request url and the original query to the response\n      // to be able to use them when debugging errors.\n      response.requestUrl = requestUrl;\n      response.query = query;\n      if (isSuccessful(response)) {\n        return Task.withValue(response);\n      } else {\n        return Task.withError(response);\n      }\n    }).thenDo(function (response) {\n      callback(null, response);\n    }, function (err) {\n      callback(err);\n    });\n    if (options.Promise) {\n      var originalCallback = callback;\n      var promise = new options.Promise(function (resolve, reject) {\n        callback = function (err, result) {\n          if (err != null) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n          originalCallback(err, result);\n        };\n      });\n      task.asPromise = function () {\n        return promise;\n      };\n    }\n    delete task.thenDo;\n    return task;\n  };\n\n  /**\n   * Adds auth information to the query, and formats it into a URL.\n   * @param {string} path\n   * @param {Object} query\n   * @param {boolean} useClientId\n   * @return {string} The formatted URL.\n   */\n  function formatRequestUrl(path, query, useClientId) {\n    if (channel) {\n      query.channel = channel;\n    }\n    if (useClientId) {\n      query.client = clientId;\n    } else if (key && key.indexOf('AIza') == 0) {\n      query.key = key;\n    } else {\n      throw 'Missing either a valid API key, or a client ID and secret';\n    }\n    var requestUrl = url.format({\n      pathname: path,\n      query: query\n    });\n\n    // When using client ID, generate and append the signature param.\n    if (useClientId) {\n      var secret = new Buffer(clientSecret, 'base64');\n      var payload = url.parse(requestUrl).path;\n      var signature = computeSignature(secret, payload);\n      requestUrl += '&signature=' + encodeURIComponent(signature);\n    }\n    return requestUrl;\n  }\n\n  /**\n   * @param {string} secret\n   * @param {string} payload\n   * @return {string}\n   */\n  function computeSignature(secret, payload) {\n    var signature = new Buffer(require('crypto').createHmac('sha1', secret).update(payload).digest('base64')).toString().replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=+$/, '');\n    while (signature.length % 4) {\n      signature += '=';\n    }\n    return signature;\n  }\n};\nexports.EXPERIENCE_ID_HEADER_NAME = EXPERIENCE_ID_HEADER_NAME;","map":{"version":3,"names":["url","require","Task","EXPERIENCE_ID_HEADER_NAME","exports","inject","options","key","process","env","GOOGLE_MAPS_API_KEY","channel","clientId","GOOGLE_MAPS_API_CLIENT_ID","clientSecret","GOOGLE_MAPS_API_CLIENT_SECRET","rate","rateLimit","limit","ratePeriod","period","makeUrlRequest","mySetTimeout","setTimeout","myClearTimeout","clearTimeout","getTime","Date","wait","attempt","ThrottledQueue","requestQueue","create","path","query","callback","retryOptions","timeout","useClientId","supportsClientId","queryOptions","isPost","method","requestUrl","formatRequestUrl","body","experienceId","join","canRetry","response","status","json","pagetoken","isSuccessful","undefined","rateLimitedGet","add","start","resolve","reject","timeoutTask","thenDo","requestTask","until","interval","increment","jitter","task","race","withValue","withError","err","Promise","originalCallback","promise","result","asPromise","client","indexOf","format","pathname","secret","Buffer","payload","parse","signature","computeSignature","encodeURIComponent","createHmac","update","digest","toString","replace","length"],"sources":["/home/vanshgoel/Downloads/ecohealth-react/node_modules/.pnpm/@google+maps@1.1.3/node_modules/@google/maps/lib/internal/make-api-call.js"],"sourcesContent":["/**\n * @license\n * Copyright 2016 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar url = require('url');\nvar Task = require('./task');\nconst EXPERIENCE_ID_HEADER_NAME = \"X-GOOG-MAPS-EXPERIENCE-ID\";\n\nexports.inject = function(options) {\n\n  var key = options.key || process.env.GOOGLE_MAPS_API_KEY;\n  var channel = options.channel;\n  var clientId = options.clientId || process.env.GOOGLE_MAPS_API_CLIENT_ID;\n  var clientSecret = options.clientSecret || process.env.GOOGLE_MAPS_API_CLIENT_SECRET;\n\n  var rate = options.rate || {};\n  var rateLimit = rate.limit || 50;  // 50 requests per ratePeriod.\n  var ratePeriod = rate.period || 1000;  // 1 second.\n\n  var makeUrlRequest = options.makeUrlRequest || require('./make-url-request');\n  var mySetTimeout = options.setTimeout || setTimeout;\n  var myClearTimeout = options.clearTimeout || clearTimeout;\n  var getTime = options.getTime || function() {return new Date().getTime();};\n  var wait = require('./wait').inject(mySetTimeout, myClearTimeout);\n  var attempt = require('./attempt').inject(wait).attempt;\n  var ThrottledQueue = require('./throttled-queue').inject(wait, getTime);\n  var requestQueue = ThrottledQueue.create(rateLimit, ratePeriod);\n\n  /**\n   * Makes an API request using the injected makeUrlRequest.\n   *\n   * Inserts the API key (or client ID and signature) into the query\n   * parameters. Retries requests when the status code requires it.\n   * Parses the response body as JSON.\n   *\n   * The callback is given either an error or a response. The response\n   * is an object with the following entries:\n   * {\n   *   status: number,\n   *   body: string,\n   *   json: Object\n   * }\n   *\n   * @param {string} path\n   * @param {Object} query This function mutates the query object.\n   * @param {Function} callback\n   * @return {{\n   *   cancel: function(),\n   *   finally: function(function()),\n   *   asPromise: function(): Promise\n   * }}\n   */\n  return function(path, query, callback) {\n\n    callback = callback || function() {};\n\n    var retryOptions = query.retryOptions || options.retryOptions || {};\n    delete query.retryOptions;\n\n    var timeout = query.timeout || options.timeout || 60 * 1000;\n    delete query.timeout;\n\n    var useClientId = query.supportsClientId && clientId && clientSecret;\n    delete query.supportsClientId;\n\n    var queryOptions = query.options || {};\n    delete query.options;\n\n    var isPost = queryOptions.method === 'POST'\n    var requestUrl = formatRequestUrl(path, isPost ? {} : query, useClientId);\n\n    if (isPost) {\n      queryOptions.body = query;\n    }\n\n    if (options.experienceId) {\n      queryOptions[\"headers\"] = queryOptions[\"headers\"] || {};\n      queryOptions[\"headers\"][\n        EXPERIENCE_ID_HEADER_NAME\n      ] = options.experienceId.join(\",\");\n    }\n\n    // Determines whether a response indicates a retriable error.\n    var canRetry = queryOptions.canRetry || function(response, query) {\n      return (\n        response == null\n        || response.status === 500\n        || response.status === 503\n        || response.status === 504\n        || (response.json && (\n            response.json.status === 'OVER_QUERY_LIMIT' ||\n            response.json.status === 'RESOURCE_EXHAUSTED' ||\n            (response.json.status ===  'INVALID_REQUEST'  && query.pagetoken))));\n    };\n    delete queryOptions.canRetry;\n\n    // Determines whether a response indicates success.\n    var isSuccessful = queryOptions.isSuccessful || function(response) {\n      return response.status === 200 && (\n                response.json == undefined ||\n                response.json.status === undefined ||\n                response.json.status === 'OK' ||\n                response.json.status === 'ZERO_RESULTS');\n    };\n    delete queryOptions.isSuccessful;\n\n    function rateLimitedGet() {\n      return requestQueue.add(function() {\n        return Task.start(function(resolve, reject) {\n          return makeUrlRequest(requestUrl, resolve, reject, queryOptions);\n        });\n      });\n    }\n\n    var timeoutTask = wait(timeout).thenDo(function() {\n      throw 'timeout';\n    });\n    var requestTask = attempt({\n      'do': rateLimitedGet,\n      until: function(response) { return !canRetry(response, query); },\n      interval: retryOptions.interval,\n      increment: retryOptions.increment,\n      jitter: retryOptions.jitter\n    });\n\n    var task =\n        Task.race([timeoutTask, requestTask])\n        .thenDo(function(response) {\n          // We add the request url and the original query to the response\n          // to be able to use them when debugging errors.\n          response.requestUrl = requestUrl;\n          response.query = query;\n\n          if (isSuccessful(response)) {\n            return Task.withValue(response);\n          } else {\n            return Task.withError(response);\n          }\n        })\n        .thenDo(\n            function(response) { callback(null, response); },\n            function(err) { callback(err); });\n\n    if (options.Promise) {\n      var originalCallback = callback;\n      var promise = new options.Promise(function(resolve, reject) {\n        callback = function(err, result) {\n          if (err != null) {\n            reject(err);\n          } else {\n            resolve(result);\n          }\n          originalCallback(err, result);\n        };\n      });\n      task.asPromise = function() { return promise; };\n    }\n\n    delete task.thenDo;\n    return task;\n  };\n\n  /**\n   * Adds auth information to the query, and formats it into a URL.\n   * @param {string} path\n   * @param {Object} query\n   * @param {boolean} useClientId\n   * @return {string} The formatted URL.\n   */\n  function formatRequestUrl(path, query, useClientId) {\n    if (channel) {\n      query.channel = channel;\n    }\n    if (useClientId) {\n      query.client = clientId;\n    } else if (key && key.indexOf('AIza') == 0) {\n      query.key = key;\n    } else {\n      throw 'Missing either a valid API key, or a client ID and secret';\n    }\n\n    var requestUrl = url.format({pathname: path, query: query});\n\n    // When using client ID, generate and append the signature param.\n    if (useClientId) {\n      var secret = new Buffer(clientSecret, 'base64');\n      var payload = url.parse(requestUrl).path;\n      var signature = computeSignature(secret, payload);\n      requestUrl += '&signature=' + encodeURIComponent(signature);\n    }\n\n    return requestUrl;\n  }\n\n  /**\n   * @param {string} secret\n   * @param {string} payload\n   * @return {string}\n   */\n  function computeSignature(secret, payload) {\n    var signature =\n        new Buffer(\n            require('crypto')\n            .createHmac('sha1', secret)\n            .update(payload)\n            .digest('base64'))\n        .toString()\n        .replace(/\\+/g, '-')\n        .replace(/\\//g, '_')\n        .replace(/=+$/, '');\n    while (signature.length % 4) {\n      signature += '=';\n    }\n    return signature;\n  }\n\n};\n\nexports.EXPERIENCE_ID_HEADER_NAME = EXPERIENCE_ID_HEADER_NAME;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}